<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="未来的美好来源于一次意外">
<meta property="og:type" content="website">
<meta property="og:title" content="吞吐知识">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="吞吐知识">
<meta property="og:description" content="未来的美好来源于一次意外">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吞吐知识">
<meta name="twitter:description" content="未来的美好来源于一次意外">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>吞吐知识</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">吞吐知识</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Docker初步学习-k/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龙葵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吞吐知识">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Docker初步学习-k/" itemprop="url">Docker初步学习-$k</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-31T09:53:17+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker是用来做什么的，举个例子，有一批货物需要运走，此时需要一种服务–运输服务，假设目前没有交通工具，但是拥有组装汽车的所有原材料（轮胎，发动机等等），想要实现运输就需要自己手动组装，并且要了解各个部件的工作原理，非常的麻烦。而Docker则会帮我们组装好一辆货车，不需要你进行麻烦且繁琐的操作，当你需要其他服务也是一样，直接通过Docker可以直接拿来使用。现在想想开发php时需要哪些服务，nginx、php-fpm、mysql、redis等，有了Docker你不需要一个一个安装、编译、配置，使用docker pull 命令可以轻松拿到这些，你要做的只是让他们之间彼此关联。 </p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个完整的Docker有以下几个部分组成：<br>1、Docker Daemon守护进程（Docker 服务，类似于mysql-server）<br>2、Docker Client客户端（使用 ‘ docker [command] ‘完成一些操作,类似于mysql-client）<br>3、Image镜像，镜像是可被Docker运行的文件，如同例子中交通工具的原材料+如何组装成货车的配置信息。<br>4、Container容器，镜像运行时的实体，在例子中Docker将原材料载入，之后加工成货车（容器），同样的原材料+同样的货车配置信息，就可以生产出多辆货车，容器也是一样。Docker可以从一个镜像运行出多个同样的容器，所以一个容器出现故障，重新启动一个就ok。容器可以被创建、启动、停止、删除、暂停。<br>当然你也可以给货车增加个导弹系统，只要你有原材料和组装导弹的配置信息，那么新产出的火车可以提供运输和作战两种服务，同理一个容器可以运行php+nginx+mysql等不同的服务，一切来源于你的镜像。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，虽然容器内是虚拟环境，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p>
<h2 id="Docker比传统虚拟机更快"><a href="#Docker比传统虚拟机更快" class="headerlink" title="Docker比传统虚拟机更快"></a>Docker比传统虚拟机更快</h2><p><img src="http://upload-images.jianshu.io/upload_images/5306603-00a830355296979e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一:  虚拟机 vs Docker"></p>
<p>Docker也是一种虚拟化技术。与传统虚拟机对比，虚拟机运行在虚拟硬件上，应用运行在虚拟机内核上。而 Docker daemon 是宿主机上的一个进程, 应用只是 Docker daemon 的一个子进程, 换句话说， 应用直接运行在宿主机内核上；虚拟机需要特殊硬件虚拟化技术支持，因而只能运行在物理机上。Docker 没有硬件虚拟化，因而可以运行在物理机、虚拟机，甚至 Docker 容器内(嵌套运行)；因为没有硬件虚拟化及多运行一个 Linux 内核的开销，应用运行在 Docker 上比虚拟机上更轻、更快。</p>
<h2 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a>运行一个容器</h2><p>了解相关概念之后开始练习使用。<br>1、首先在你的电脑上完成Docker的<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">安装</a>，<br>2、寻找自己想要使用的镜像文件<br>去<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>（是一个集中存储镜像的服务，称为<strong>Docker Registry</strong>）上检索自己想要使用的服务，检索出的每条内容被称为一个仓库（Repository），每个仓库中有多个标签（tags，如php：5.5，其中php是仓库名，5.5是标签），一个标签对应一个镜像，拉取镜像到本地的命令是 ‘docker pull 镜像名:仓库名’， 如<br><code>docker pull php:5.5</code></p>
<p>当标签是 latest 时，可省略：<br><code>docker pull php 等同于 docker pull php:latest</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-8b49137fefa0037e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二：docker hub 检索结果"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-7e82e54f90a6a23c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三：含有多个标签的 php 仓库"></p>
<p>也可以通过命令行搜索，如搜索php相关镜像：<br><code>docker search php</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-a5dce1f3a56d0f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四： docker search 结果"></p>
<p>请尝试下载一个nginx 镜像到本地，要指定标签。<br>3、查看本地镜像列表<br><code>docker images</code></p>
<p>4、创建容器<br><code>docker run -d --name nginx-test -v /var/www:/var/www -p 8080:80  nginx</code></p>
<p>-d,让容器在后台执行；<br>–name，给容器分配名字<br>-v，挂载数据卷。容器像正常的Linux系统一样可以存储数据，但是当运行的容器出现故障不能正常启动时，我们就要通过同样的镜像运行一个新的容器实例，容器运行的服务是相同的，但是彼此隔离，不能共用数据，所以要通过数据卷的挂载实现数据的持久化。-v相当于把主机的/var/www目录同步到容器中的/var/www目录，如果容器不存在这个目录，则自动创建，挂载后两个文件夹实现了数据双向同步，每个容器的数据得以保存。新启用的nginx容器实例通过同样的挂载方式可以直接使用之前的数据。想要修改容器中nginx服务的配置，就要使用到数据卷，因为这是可变数据。数据卷是一个可供一个或多个容器使用的特殊目录，有如下特点，数据卷可以在容器之间共享和重用；对数据卷的修改会立马生效；对数据卷的更新，不会影响镜像；数据卷默认会一直存在，即使容器被删除<br>-p，端口映射，主机的8080端口映射到容器的80端口，此时访问主机8080会转到容器的80端口来获取数据<br>最后的nginx就是仓库名，会寻找nginx:latest的镜像启动，这里也可用本地镜像的id，镜像id通过 docker images 命令 可以得到</p>
<h2 id="容器的管理"><a href="#容器的管理" class="headerlink" title="容器的管理"></a>容器的管理</h2><p>容器启动之后，查看本地正在运行的容器<br><code>docker ps</code></p>
<p>查看本地所有容器，包括运行中和暂停运行的<br><code>docker ps -a</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-65669cc976657a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图五 : docker ps -a 结果"></p>
<p>将暂停的容器启动<br><code>docker start 容器名称/容器id（容器id可用 docker ps 查看）</code></p>
<p>暂停一个运行的容器<br><code>docker stop 容器名称/容器id</code></p>
<p>删除一个容器,删除正在运行的容器要增加 -f 参数<br><code>docker rm 容器名称/容器id</code></p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>进入容器的方式有多种，这里只介绍和推荐使用Docker自带的docker exec方式，Docker1.3增加新的exec命令行工具，进入container更加方便：<br><code>docker exec -i -t  容器名称/id  bash</code></p>
<p>bash是容器系统的shell，如容器是centos系统，shell可以是bash、sh，进入容器后，尝试运行 ‘ ls / ‘ 命令</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尝试运行一个容器实例，这会让你对Docker的有进一步理解。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://jm.taobao.org/2016/05/12/introduction-to-docker/" target="_blank" rel="noopener">http://jm.taobao.org/2016/05/12/introduction-to-docker/</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/basic_concept/container.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/basic_concept/container.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Docker-k-搭建一套php开发环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龙葵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吞吐知识">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Docker-k-搭建一套php开发环境/" itemprop="url">Docker($k)搭建一套php开发环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-31T09:52:01+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>下面内容将介绍如何把容器当作一个命令来使用以及搭建一套php+nginx的 web 服务，这里需要两个镜像，用两个镜像的主要目的是学习如何让 Docker 容器之间相互通信。阅读完下面的内容就可以搭建自己的 Docker 服务了。</p>
<h2 id="把-php-容器当作命令行使用"><a href="#把-php-容器当作命令行使用" class="headerlink" title="把 php 容器当作命令行使用"></a>把 php 容器当作命令行使用</h2><p>镜像下载：<br><code>docker pull php:7.0-fpm-alpine php</code><br>这里的镜像是基于 <a href="https://alpinelinux.org/" target="_blank" rel="noopener">alpine</a> 系统的，因为基于alpine系统的镜像文件会比较小，下载速度更快。由于国内下载镜像文件较慢，推荐使用镜像加速器<a href="http://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud</a>。<br><img src="http://upload-images.jianshu.io/upload_images/5306603-4834550be10bce02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一：docker images | grep php"></p>
<p>下载镜像是为了搭建一个 web 服务，如果只想简单的使用 php 命令行，怎么办？我们知道从镜像启动的容器中肯定是可以使用命令行，如果每次使用 php 命令行都进入容器，显得特别麻烦，其实 Docker 可以这样用：<br><code>docker run -it --rm  php:7.0-fpm-alpine php --version</code><br><img src="http://upload-images.jianshu.io/upload_images/5306603-d76bb6d80410473b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二：把php容器当作命令行使用"><br>命令比较长，给它设置个别名就好多了。下面介绍下相关参数：<br>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–rm：容器退出时自动删除，如果不加这个参数，当你执行完上面的命令，php容器会退出，变为一个暂停状态的容器，通过 <code>docker ps -a</code> 可以查询到；<br>php –version：在容器名后面的字符会被当作容器的shell命令来处理；<br>*注：关于参数 -i -t ，这里上面的命令可以不加，因为没有交互操作，在使用node容器的命令行时会有交互，需要加上，两个参数同时使用就好：<br><code>docker run -i -t --rm node:alpine node</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-d96f8843e4eb70c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三：node容器命令行的使用"></p>
<p>想用容器同时执行多个命令，不能直接在后面加 <code>&amp;&amp;</code>，需要使用 <code>sh -c</code>来实现，：<br><code>docker run  --rm  php:7.0-fpm-alpine sh -c &#39; echo &quot;123&quot; &amp;&amp; echo &quot;456&quot; &#39;</code></p>
<h2 id="启动php服务"><a href="#启动php服务" class="headerlink" title="启动php服务"></a>启动php服务</h2><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">	-d \</span><br><span class="line">	--name php \</span><br><span class="line">	-v /root/docker/etc/php/php.ini:/usr/local/etc/php/conf.d/php.ini:ro \</span><br><span class="line">	-v /root/docker/html:/var/www/html \</span><br><span class="line">	php:7.0-fpm-alpine</span><br></pre></td></tr></table></figure></p>
<p>-d：后台运行容器，并且返回容器 ID；<br>–name：给容器命名，容器名是唯一的，操作容器时可以使用名称代替容器 ID；<br>:ro：表示挂载的文件或者文件夹为只读模式；<br>从命令可以知道容器是后台运行，名字是 php，它挂载了主机的一个文件 php.ini 和一个目录 /root/docker/html，并且 php.ini 是只读的，所以在容器内不可以对这个文件做修改。/usr/local/etc/php/conf.d 这个目录是容器中的 php 读取用户自定义配置文件的目录，正常情况下都可以在 Docker Hub 上有说明，如果没有可以自己运行 <code>phpinfo();</code> 来查看。之前介绍过，只要挂载，那么本地主机目录就会和容器内的目录同步。需要修改容器的 php 配置时，只要在主机本地编辑保存这个 php.ini 文件，然后执行：<br><code>docker restart php （php是容器名字）</code></p>
<h2 id="php-容器和-nginx-容器通信"><a href="#php-容器和-nginx-容器通信" class="headerlink" title="php 容器和 nginx 容器通信"></a>php 容器和 nginx 容器通信</h2><p>首先下载nginx镜像：<br><code>docker pull nginx:stable-alpine</code><br>启动 nginx 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">	-d \</span><br><span class="line">	--link php \</span><br><span class="line">	--name nginx \</span><br><span class="line">	-v /root/docker/etc/nginx/conf.d/:/etc/nginx/conf.d/ \</span><br><span class="line">	-v /root/docker/html:/var/www/html \</span><br><span class="line">        -v /var/log/nginx:/var/log/nginx \</span><br><span class="line">	-p 8088:80 \</span><br><span class="line">	nginx:stable-alpine</span><br></pre></td></tr></table></figure></p>
<p>–link：确保 nginx 可以与 php 之间通信，在 nginx 容器中直接  <code>ping php</code> 是可以通的，实际上加上这个参数后，会在 nginx 容器增加 host 解析，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-04260da4a4a546ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四：nginx与php之间通信"><br>增加 nginx 虚拟主机配置，放到主机目录  /root/docker/etc/nginx/conf.d 下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	root /var/www/html;</span><br><span class="line">	# Add index.php to the list if you are using PHP</span><br><span class="line">	index index.php index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">	location ~ \.php$ &#123;</span><br><span class="line">		fastcgi_pass php:9000;</span><br><span class="line">                fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">		include        fastcgi_params;</span><br><span class="line">	&#125;</span><br><span class="line">	access_log /var/log/nginx/access.log;</span><br><span class="line">	error_log /var/log/nginx/error.log  debug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fastcgi_pass 后面使用的 php 就是 –link 参数增加的host解析，直接用别名代替ip地址，更加方便。然后重启 nginx 服务：<br><code>docker restart nginx</code><br>在 主机本地的 /root/docker/html 目录新建 index.php：<br><code>echo &quot;&lt;?php\nphpinfo();&quot; | tee /root/docker/html/index.php</code><br>现在一个 web 服务搭建好了，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-9e68506a92c18fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图五：web服务"></p>
<h2 id="查看-nginx-日志"><a href="#查看-nginx-日志" class="headerlink" title="查看 nginx 日志"></a>查看 nginx 日志</h2><p>容器内 nginx 的日志会写入容器内的 /var/log/nginx 目录下，由于这个目录和主机的 /var/log/nginx 目录是同步的，所以，想看容器内 nginx 的日志，查看主机的文件 /var/log/nginx/access.log 就可以：<br> <code>tail -f /var/log/nginx/access.log</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-c2d664e8bcf92ab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图六：本地查看nginx容器访问日志"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基本的启动配置服务的命令上面都有介绍，自己可以尝试给这个 web 服务增加个 mysql<br> 存储功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Chromeless-Demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龙葵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吞吐知识">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Chromeless-Demo/" itemprop="url">Chromeless Demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-31T09:50:33+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chromeless-简介"><a href="#Chromeless-简介" class="headerlink" title="Chromeless 简介"></a>Chromeless 简介</h2><p>Chrome 浏览器有一种模式叫做 Chrome Headless，在这种模式下，允许你正常运行 Chrome 浏览器，但是没有界面；想要调试这种模式下打开的网站，可以通过它提供的接口来实现，而 <a href="https://github.com/graphcool/chromeless" target="_blank" rel="noopener">Chromeless</a> 就是把这层接口做了封装，让你使用接口更方便。通过它，可以控制浏览器行为，如打开网站、点击按钮、填充表单、获取 DOM 元素…</p>
<h2 id="可以用来做什么"><a href="#可以用来做什么" class="headerlink" title="可以用来做什么"></a>可以用来做什么</h2><p>1 .  可以<a href="https://github.com/graphcool/chromeless/blob/master/examples/google-screenshot.js" target="_blank" rel="noopener">获取网页截图</a><br>2 .  根据页面 document 文档<a href="https://github.com/graphcool/chromeless/blob/master/examples/google-pdf.js" target="_blank" rel="noopener">生成 PDF 文件</a><br>3 .  编写测试代码，自动化测试网页<br>4 .  基于真实的浏览器环境，可以编写爬虫程序</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先要安装支持 Chrome Headless 模式的浏览器。目前，Mac 上 Chrome 59 beta<br>版本与 Linux 上的 Chrome 57+ 已经开始支持 headless 特性。Windows 上 Chrome 暂时不支持，可以使用 <a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="noopener">Chrome Canary 60</a> 进行开发。<br>下面是 Ubuntu17.10 的无界面浏览器启动命令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">google-chrome \</span><br><span class="line">--remote-debugging-port=9222 \</span><br><span class="line">--disable-gpu \</span><br><span class="line">--no-sandbox  \</span><br><span class="line">--headless</span><br></pre></td></tr></table></figure></p>
<p>Chromeless 用 NodeJS 编写，要求 NodeJS 版本8.2+，安装：<br><code>npm install chromeless</code></p>
<h2 id="如何用于网页测试"><a href="#如何用于网页测试" class="headerlink" title="如何用于网页测试"></a>如何用于网页测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Chromeless &#125; = require(&apos;chromeless&apos;)</span><br><span class="line">const &#123; expect &#125;  = require(&apos;chai&apos;)</span><br><span class="line"></span><br><span class="line">async function run()&#123;</span><br><span class="line">	const chromeless = new Chromeless()</span><br><span class="line">	const firstPage= await chromeless</span><br><span class="line">		.goto(&apos;http://www.w3school.com.cn&apos;)</span><br><span class="line">		.wait(&apos;#navsecond&apos;)</span><br><span class="line">		.evaluate(() =&gt; &#123;</span><br><span class="line">  			  // this will be executed in Chrome</span><br><span class="line">  			  const links = [].map.call(</span><br><span class="line">  			    document.querySelectorAll(&apos;#navsecond ul:nth-child(2) li&apos;),</span><br><span class="line">  			    a =&gt; (a.innerText.trim())</span><br><span class="line">  			  )</span><br><span class="line">  			  return links</span><br><span class="line">  			&#125;)</span><br><span class="line">expect(firstPage).to.have.members([&quot;JS&quot;,&quot;HTML5&quot;,&quot;XHTML&quot;,&quot;CSS&quot;,&quot;CSS3&quot;,&quot;TCP/IP&quot;])</span><br><span class="line">await chromeless.end()</span><br><span class="line">&#125;</span><br><span class="line"># 运行并捕捉错误</span><br><span class="line">run().catch(console.error.bind(console))</span><br></pre></td></tr></table></figure>
<p>这里用到了 <a href="http://chaijs.com/api/bdd/" target="_blank" rel="noopener">Chai</a> 断言库，代码实现的功能是验证 <a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3school</a> 网站首页，左侧第一个 ul 列表的内容是否包含以下内容： JS、HTML5、XHTML、CSS、CSS3、TCP/IP”。<br>命令详解：<br>goto：打开加载网站 <code>http://www.w3school.com.cn</code>；<br>wait：等待指定的元素 <code>#navsecond</code>（这是 <a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">CSS selector</a>） 渲染成功之后才往下执行；<br>evaluate：会将里面的 JS 代码送到 浏览器中执行，并获取返回结果；<br>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/5306603-2d9f002f40084a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一：网页测试Demo结果"></p>
<h2 id="如何爬取-Google-Search-Result"><a href="#如何爬取-Google-Search-Result" class="headerlink" title="如何爬取 Google Search Result"></a>如何爬取 Google Search Result</h2><p>下面代码实现的功能是使用 Google Search 搜索关键字，并返回结果的 Title 和链接地址。<br><a href="https://asciinema.org/a/KlCxZMtSAlpQj9AHhSs8kSIVq" target="_blank" rel="noopener">查看执行结果</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Chromeless &#125; = require(&apos;chromeless&apos;);</span><br><span class="line"></span><br><span class="line">async function run()&#123;</span><br><span class="line">	const chromeless = new Chromeless()</span><br><span class="line">	const firstPage= await chromeless</span><br><span class="line">		.goto(&apos;https://www.google.com&apos;)</span><br><span class="line">		.wait(&apos;input[name=&quot;q&quot;]&apos;)</span><br><span class="line">		.type(&apos;云纵&apos;, &apos;input[name=&quot;q&quot;]&apos;)</span><br><span class="line">		.press(13) // press enter</span><br><span class="line">		.wait(&apos;#foot&apos;)</span><br><span class="line">		</span><br><span class="line">	let hasNextPage = true</span><br><span class="line">	let page = 1</span><br><span class="line">	let result = null</span><br><span class="line">	while (hasNextPage)&#123;</span><br><span class="line">		if(page===1)&#123;</span><br><span class="line">			result = await chromeless</span><br><span class="line">				.evaluate(() =&gt; &#123;</span><br><span class="line">  				  // this will be executed in Chrome</span><br><span class="line">  				  const links = [].map.call(</span><br><span class="line">  				    document.querySelectorAll(&apos;.g h3 a&apos;),</span><br><span class="line">  				    a =&gt; (&#123;title: a.innerText, href: a.href&#125;)</span><br><span class="line">  				  )</span><br><span class="line">  				  return links</span><br><span class="line">  				&#125;)</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			result = await chromeless</span><br><span class="line">				.scrollTo(200,400)</span><br><span class="line">				.scrollToElement(&apos;#foot td:nth-last-child(1)&apos;)</span><br><span class="line">				.click(&apos;#foot td:nth-last-child(1)&apos;)</span><br><span class="line">				.wait(2000)</span><br><span class="line">				.wait(&apos;#foot&apos;)</span><br><span class="line">				.evaluate(() =&gt; &#123;</span><br><span class="line">	                          // this will be executed in Chrome</span><br><span class="line">	                          const links = [].map.call(</span><br><span class="line">	                            document.querySelectorAll(&apos;.g h3 a&apos;),</span><br><span class="line">	                            a =&gt; (&#123;title: a.innerText, href: a.href&#125;)</span><br><span class="line">	                          )</span><br><span class="line">	                          return links</span><br><span class="line">	                        &#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		console.log(result)</span><br><span class="line">		hasNextPage = await chromeless.evaluate(() =&gt; &#123;</span><br><span class="line">  			  let nextPage =  document.querySelector(&apos;#foot td:nth-last-child(1)&apos;).innerText</span><br><span class="line">  			  //return (nextPage===&apos;Next&apos;)</span><br><span class="line">  			  return nextPage.length</span><br><span class="line">  			&#125;)</span><br><span class="line">		console.log(`第$&#123;page&#125;页`)</span><br><span class="line">		console.log(hasNextPage ? &apos;存在下一页&apos; : &apos;不存在下一页&apos;)</span><br><span class="line">		page++</span><br><span class="line">	&#125;</span><br><span class="line">	await chromeless.end()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run().catch(console.error.bind(console))</span><br></pre></td></tr></table></figure>
<p>命令解释：<br><code>.type(&#39;云纵&#39;, &#39;input[name=&quot;q&quot;]&#39;)</code>： 在 CSS 选择器 <code>input[name=&quot;q&quot;]</code> 选中的元素（实际上就是 Google Search 搜索框）内输入’云纵‘两个字；<br><code>.press(13)</code> ：按下键盘的 Enter 键，就是在搜索框输入文字后执行查询；<br> <code>.scrollTo(200,400)</code> ：滚动到距离页面左侧200px，右侧400px的位置；<br><code>.scrollToElement(&#39;#foot td:nth-last-child(1)&#39;)</code>：滚动到 CSS 选择器 <code>#foot td:nth-last-child(1)</code> 选中元素（实际是 Google Search Result 的下一页链接），使元素可见；<br><code>.click(&#39;#foot td:nth-last-child(1)&#39;)</code>：点击元素；<br><code>.wait(2000)</code>：参数是数字时，表示等待时间，参数是 CSS 选择器时表示等待元素渲染完成；</p>
<h2 id="Async-与-Await"><a href="#Async-与-Await" class="headerlink" title="Async 与 Await"></a>Async 与 Await</h2><p>开发时要注意这两个关键字 async 和 await，使用 Chromeless，会用到他们，这是 ES7 实现的异步方案，需要了解以下内容：<br>1 .  function 前面的 async 标识符表示函数内有异步操作；<br>2 .  await 强调后面的异步操作执行完成后才能继续；<br>3 .  await 只能用在async标识的函数内；<br>4 .  await 后写非异步操作也可以，会直接执行</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1 .  <a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="noopener">体验异步的终极解决方案-ES7的Async/Await</a><br>2 .  <a href="https://zhuanlan.zhihu.com/p/27100187" target="_blank" rel="noopener">初探 Headless Chrome</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Supervisor-让崩溃的程序自动重启/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="龙葵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吞吐知识">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Supervisor-让崩溃的程序自动重启/" itemprop="url">Supervisor 让崩溃的程序自动重启</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-31T09:22:05+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Supervisor-介绍"><a href="#Supervisor-介绍" class="headerlink" title="Supervisor 介绍"></a>Supervisor 介绍</h3><p>Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器由于某种原因暂时 kill 掉你的应用，此时可以用 Supervisor 让你的应用自动重启，如果是多个应用被杀死，也省去了手动一个一个地敲命令重新启动。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>目前 Supervisor 只能运行在 Unix-Like 的系统上，无法运行在 Windows 上。Supervisor 官方版目前只能运行在 Python 2.4 以上版本，但是还无法运行在 Python 3 上。执行下面代码前，需要<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">安装 pip</a>：</p>
<pre><code>pip install supervisor
</code></pre><p>安装完成后，可以使用两个命令，分别是 <code>supervisord</code> 和 <code>supervisorctl</code>,如果你的系统里有两个版本的 Python，且默认的 <code>python</code> 命令版本是 Python 3,此时运行会出错，解决方式是修改两个命令使用的 Python 版本。使用 <code>which</code> 命令找到两个命令的文件地址，然后编辑文件并指定 Python 版本：<br><img src="http://upload-images.jianshu.io/upload_images/5306603-42fbaf472b45e0dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改 Python 版本"></p>
<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>将下面内容保存到 <code>/etc/supervisor/supervisord.conf</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">; 基础配置样例</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/var/run/supervisor.sock   ; (the path to the socket file)</span><br><span class="line">chmod=0700                       ; sockef file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">childlogdir=/var/log/supervisor            ; (&apos;AUTO&apos; child log dir, default $TEMP)</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files = /etc/supervisor/conf.d/*.conf ;加载其他配置文件</span><br><span class="line"></span><br><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=*:9001                ; 通过网页可以控制子进程</span><br><span class="line">;username=user              ; (default is no username (open server))</span><br><span class="line">;password=123               ; (default is no password (open server))</span><br><span class="line"></span><br><span class="line">; 进程的配置样例</span><br><span class="line"></span><br><span class="line">; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名，这里的进程名是 your_program_name</span><br><span class="line">[program:your_program_name] </span><br><span class="line">;numprocs=1                 ; 进程数量，默认为1</span><br><span class="line">;process_name=%(program_name)s   ; 默认为 %(program_name)s，即 [program:x] 中的 x</span><br><span class="line">directory=/home/yiming ; 执行 command 之前，先切换到工作目录</span><br><span class="line">command=python test.py</span><br><span class="line">autostart=true ;如果设置为true，当supervisord启动的时候，进程会自动重启。</span><br><span class="line">user=yiming                 ; 使用 yiming 用户来启动该进程</span><br><span class="line">autorestart=true   ; 程序崩溃时自动重启，重启次数是有限制的，默认为3次</span><br><span class="line">startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了           </span><br><span class="line">redirect_stderr=true        ; 错误日志重定向到标准输出</span><br><span class="line">loglevel=info</span><br></pre></td></tr></table></figure></p>
<p>现在以守护进程的方式启动 <code>test.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure>
<p>此时命令 <code>python test.ty</code> 已经被执行，因为进程配置样例中有 <code>autostart=true</code>，所以 Supervisord 服务运行后启动进程 your_program_name ，并把 your_program_name 进程作为自己的子进程，所以当进程 your_program_name 挂掉后，Supervisord 会收到通知，然后可以再次将 your_program_name 作为子进程启动。</p>
<h3 id="模拟程序异常退出"><a href="#模拟程序异常退出" class="headerlink" title="模拟程序异常退出"></a>模拟程序异常退出</h3><p>如下图，名称为 echo 的进程被杀掉两次，之后都会被重新启动，右侧是 Supervisord 日志记录了  echo 进程状态的变化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5306603-8e9dac42e1906d30.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功能演示"></p>
<h3 id="使用-supervisorctl-管理进程"><a href="#使用-supervisorctl-管理进程" class="headerlink" title="使用 supervisorctl 管理进程"></a>使用 supervisorctl 管理进程</h3><ul>
<li><p>停止某一个进程，program_name 为 [program:x] 里的 x：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop program_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动某个进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start program_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启某个进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl restart program_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止全部进程，注：start、restart、stop 都不会载入最新的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop all</span><br></pre></td></tr></table></figure>
</li>
<li><p>载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Web-管理"><a href="#Web-管理" class="headerlink" title="Web 管理"></a>Web 管理</h3><p><img src="http://upload-images.jianshu.io/upload_images/5306603-4a7b683d50405b4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Web 管理进程"></p>
<p>Supervisor 可以在界面上管理进程，Web Server 其实是通过 XML_RPC 来实现的，可以向Supervisor 请求数据，也可以控制 Supervisor 及子进程。配置在 <code>[inet_http_server]</code> 块里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=*:9001                ; 通过网页可以控制子进程</span><br><span class="line">;username=user              ; (default is no username (open server))</span><br><span class="line">;password=123               ; (default is no password (open server))</span><br></pre></td></tr></table></figure>
<h3 id="配置参数介绍"><a href="#配置参数介绍" class="headerlink" title="配置参数介绍"></a>配置参数介绍</h3><table>
<thead>
<tr>
<th>参数</th>
<th>参数解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>command</td>
<td>启动程序使用的命令，可以是绝对路径或者相对路径</td>
</tr>
<tr>
<td>process_name</td>
<td>一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s</td>
</tr>
<tr>
<td>numprocs</td>
<td>Supervisor启动这个程序的多个实例，如果numprocs&gt;1，则process_name的表达式必须包含%(process_num)s，默认是1</td>
</tr>
<tr>
<td>numprocs_start</td>
<td>一个int偏移值，当启动实例的时候用来计算numprocs的值</td>
</tr>
<tr>
<td>priority</td>
<td>权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999</td>
</tr>
<tr>
<td>autostart</td>
<td>如果设置为true，当supervisord启动的时候，进程会自动重启。 </td>
</tr>
<tr>
<td>autorestart</td>
<td>值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。</td>
</tr>
<tr>
<td>startsecs</td>
<td>程序启动后等待多长时间后才认为程序启动成功</td>
</tr>
<tr>
<td>startretries</td>
<td>supervisord尝试启动一个程序时尝试的次数。默认是3</td>
</tr>
<tr>
<td>exitcodes</td>
<td>一个预期的退出返回码，默认是0,2。</td>
</tr>
<tr>
<td>stopsignal</td>
<td>当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。</td>
</tr>
<tr>
<td>stopwaitsecs</td>
<td>在操作系统给supervisord发送SIGCHILD信号时等待的时间</td>
</tr>
<tr>
<td>stopasgroup</td>
<td>如果设置为true，则会使supervisor发送停止信号到整个进程组</td>
</tr>
<tr>
<td>killasgroup</td>
<td>如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。</td>
</tr>
<tr>
<td>user</td>
<td>如果supervisord以root运行，则会使用这个设置用户启动子程序</td>
</tr>
<tr>
<td>redirect_stderr</td>
<td>如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。</td>
</tr>
<tr>
<td>stdout_logfile</td>
<td>把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。</td>
</tr>
<tr>
<td>stdout_logfile_maxbytes</td>
<td>标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</td>
</tr>
<tr>
<td>stdout_logfile_backups</td>
<td>标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份</td>
</tr>
<tr>
<td>stdout_capture_maxbytes</td>
<td>当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</td>
</tr>
<tr>
<td>stdout_events_enabled</td>
<td>如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</td>
</tr>
<tr>
<td>stderr_logfile</td>
<td>把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true</td>
</tr>
<tr>
<td>stderr_logfile_maxbytes</td>
<td>错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小</td>
</tr>
<tr>
<td>stderr_logfile_backups</td>
<td>错误日志轮转备份的数量，默认是10，如果设置为0，则不备份</td>
</tr>
<tr>
<td>stderr_capture_maxbytes</td>
<td>当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB</td>
</tr>
<tr>
<td>stderr_events_enabled</td>
<td>如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发</td>
</tr>
<tr>
<td>environment</td>
<td>一个k/v对的list列表</td>
</tr>
<tr>
<td>directory</td>
<td>supervisord在生成子进程的时候会切换到该目录</td>
</tr>
<tr>
<td>umask</td>
<td>设置进程的umask</td>
</tr>
<tr>
<td>serverurl</td>
<td>是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">龙葵</p>
              <p class="site-description motion-element" itemprop="description">未来的美好来源于一次意外</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龙葵</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
