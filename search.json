[{"categories":null,"content":" 打开 Chrome 调起开发者工具 Command+option+j 按下 Command+shift+p 输入 full 按下回车键 Done  ","description":"","tags":null,"title":"Chrome自带网页长截图功能","uri":"/posts/chrome%E8%87%AA%E5%B8%A6%E7%BD%91%E9%A1%B5%E9%95%BF%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD/"},{"categories":null,"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( \"fmt\" \"math/rand\" \"time\" ) func timeCost() func() { start := time.Now() return func() { // 纳秒 \tprintln(\"time cost \", time.Since(start)) } }  func testBuble(arr []int) []int { defer timeCost()() return bubble(arr) } func main() { source := rand.Perm(1000) fmt.Println(source) fmt.Println(testBuble(source)) return } func bubble(arr []int) []int { l := len(arr) for i := 0; i \u003c l; i++ { for j := 0; j \u003c l-i-1; j++ { if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] \t} } } return arr }   ","description":"","tags":["golang","bubble"],"title":"Golang实现冒泡排序","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"categories":null,"content":".主讲人：周孝正\n ","description":"","tags":["podcasts"],"title":"【播客第3期】中国面临的挑战与机遇","uri":"/posts/podcasts-0003/"},{"categories":null,"content":"故事简介 男主与女主吵架，女主特别生气，回了娘家。 男主思来想去，大丈夫不拘小节，应把女主接回来。 男主上门，女主生气在主卧，不让见 403 次日上门，女主生气逛街，不知去向，没找到 404 次日再来，被告知娘家买新房，女主在另一套 302 转至另一套，男主入室见到女主，但聊的不嗨，中途吵架，Game Over! 500 次日，娘家买新房后，这套卖了，所以女主全家只能在另一套 301 转至另一套，岳母不忍姑娘受气，将男主拦在门外，“此路是我开，此树是我栽，所以此路不通” 502 次日，女主见有人帮忙出气，便怨气消散，命男主今日子时来见，不巧男主来晚，岳母便觉心中无我儿者滚之，不等，今日不回 504 次日，但女主睡觉踢被子着凉，重感冒，病倒在床 503 女主和男主牵手返回家中 200，这个日期且叫它 末日 500系理解 `500` 应用内部错误，如数据库、代码逻辑问题； `502` 网关错误，从客户端到应用服务内，可能经过多个转发组件（代理），其中的组件发生错误，如 DNS 挂了或者组件接收到了不能识别的返回值；而 `504` 一般是中间的这些组件等待时间超过了自己的设置，原因是应用没能及时返回； `503` 一般是应用挂掉或者应用达到最大处理能力，拒绝新的连接请求。 参考链接 Server Error – 500 vs 502 vs 503 vs 504\n","description":"","tags":["http"],"title":"HTTP 状态码500 502 503 504 详解","uri":"/posts/server-return-code-503-or-504/"},{"categories":null,"content":"场景 .线上服务偶尔报 504 Gateway timeout，一般在量大的时候出现。\n原因 线上服务运行在 k8s 集群中，集群使用了 Istio ，Istio 的 Envoy 代理等待目标服务返回的超时时间默认值为 15 秒，这里使用的 Istio 版本为 Istio-v1.1.5，其他版本自行测试。\n解决方法 在 Istio 的虚拟服务中添加超时设置，调整为 30 秒，如下：\napiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - route: - destination: host: reviews subset: v2 timeout: 30s 参考链接 Istio 默认超时\n","description":"","tags":["istio","error"],"title":"【已解决】k8s服务报504网关超时","uri":"/posts/istio-request-timeout/"},{"categories":null,"content":".主讲人：罗永浩\n ","description":"","tags":["podcasts"],"title":"【播客第2期】我的奋斗","uri":"/posts/podcasts-0002/"},{"categories":null,"content":".主讲人：周孝正\n ","description":"","tags":["podcasts"],"title":"【播客第1期】中国社会问题分析","uri":"/posts/podcasts-0001/"},{"categories":null,"content":"简介 Mac系统版本升级到10.15.6后，Goland IDE 编译 go 项目时报错：\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决 xcode-select --install 这时如果还是报错，请执行这个：\nsudo xcode-select --reset 参考  Mac OS Error  ","description":"","tags":["mac","error"],"title":"【已解决】Mac OS Upgrade Xcrun Error","uri":"/posts/mac-upgrade-xcrun-error/"},{"categories":null,"content":"","description":"","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"需求 前端修改页面路由，但同时应该兼容旧的路由，保证旧的路由转到新路由上去\n$host/index.html#/args?sign=xxx ==\u003e $host/index.html#/new/args?sign=xxx 过程 首先想到的就是使用 nginx 重写路由，可惜想法是好的，但 nginx 做不到。巧妇难为无米之炊，浏览器不会把 # 号后的内容发送给 nginx ，所以凉凉了。\n解决 如果遇到这种需求，应该考虑在前端做中间页，通过中间页跳转的方式实现。\n参考  Nginx discards data after number sign (#) URL中“#” “？” \u0026“”号的作用  ","description":"","tags":["nginx","write"],"title":"【已解决】Nginx Rewrite 重写带#号的路由","uri":"/posts/nginx-rewrite-%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%E5%B8%A6%E4%BA%95%E5%8F%B7%E7%9A%84%E8%B7%AF%E7%94%B1/"},{"categories":null,"content":"安装acme.sh curl https://get.acme.sh | sh 命令简介 申请证书需要对你的域名进行验证，使用本地 Nginx 验证：\n~/.acme.sh/acme.sh --issue -d 你的域名 --nginx 上面这条命令会在 ~/.acme.sh 文件夹下生成域名相关的证书文件，而 nginx 读取的证书文件最好在 /etc/nginx 中，下面的命令会把文件复制一份到 /etc/nginx/ssl 下。\n~/.acme.sh/acme.sh --installcert -d 你的域名 \\ --key-file /etc/nginx/ssl/你的域名/你的域名.key \\ --fullchain-file /etc/nginx/ssl/你的域名/fullchain.cer \\ --reloadcmd \"service nginx force-reload\" 还有一步，就是在nginx上加证书配置，如下：\nserver { listen 443; server_name 你的域名; ssl on; root /var/www/html; index index.html index.htm; ssl_certificate /etc/nginx/ssl/你的域名/fullchain.cer; ssl_certificate_key /etc/nginx/ssl/你的域名/你的域名.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; add_header Strict-Transport-Security \"max-age=63072000; includeSubdomains; preload\"; location / { index index.html index.htm; } } 重启nginx，测试证书有效性：\nnginx -t \u0026\u0026 nginx -s reload ","description":"","tags":["acme","nginx"],"title":"Acme为nginx生成https证书","uri":"/posts/acme%E4%B8%BAnginx%E7%94%9F%E6%88%90https%E8%AF%81%E4%B9%A6/"},{"categories":null,"content":"介绍 sed 是一种流编辑器，是Unix常见的命令行程序。能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。\tSed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。\n校验数据格式 有时在本机做测试，需要从网上下载比较大的 CSV 文件，然而在导入数据库的过程中报错。做的友好一点的数据库会告诉你是格式错误，遇到不友好的就要折腾一番。为了避免这种情况，可以在下载文件后直接用 sed 命令检查下数据格式是否正确。 查看下载文件 hotel.csv 的正确数据格式： head -n 1 hotel.csv\n如图，正确的数据格式应该是每行32个以逗号分割的字段，用 sed 检查是否有错误格式的数据：\nsed -E '/([^,]*,){31}/d' hotel.csv\n参数 -E：表示后面是标准正则； 字符 d：表示把正则匹配的行都删除，所以会显示不匹配的行；\n不要试图去找各种牛X的软件去做这件事，因为一般这种文件会达到几个 G，打开它需要很大内存，而sed每次处理一行。\n","description":"","tags":["sed","csv"],"title":"用 sed 命令校验数据格式","uri":"/posts/%E7%94%A8-sed-%E5%91%BD%E4%BB%A4%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"categories":null,"content":"Docker简介 Docker是用来做什么的，举个例子，有一批货物需要运走，此时需要一种服务–运输服务，假设目前没有交通工具，但是拥有组装汽车的所有原材料（轮胎，发动机等等），想要实现运输就需要自己手动组装，并且要了解各个部件的工作原理，非常的麻烦。而Docker则会帮我们组装好一辆货车，不需要你进行麻烦且繁琐的操作，当你需要其他服务也是一样，直接通过Docker可以直接拿来使用。现在想想开发php时需要哪些服务，nginx、php-fpm、mysql、redis等，有了Docker你不需要一个一个安装、编译、配置，使用docker pull 命令可以轻松拿到这些，你要做的只是让他们之间彼此关联。\n基本概念 一个完整的Docker有以下几个部分组成： 1、Docker Daemon守护进程（Docker 服务，类似于mysql-server） 2、Docker Client客户端（使用 ' docker [command] ‘完成一些操作,类似于mysql-client） 3、Image镜像，镜像是可被Docker运行的文件，如同例子中交通工具的原材料+如何组装成货车的配置信息。 4、Container容器，镜像运行时的实体，在例子中Docker将原材料载入，之后加工成货车（容器），同样的原材料+同样的货车配置信息，就可以生产出多辆货车，容器也是一样。Docker可以从一个镜像运行出多个同样的容器，所以一个容器出现故障，重新启动一个就ok。容器可以被创建、启动、停止、删除、暂停。 当然你也可以给货车增加个导弹系统，只要你有原材料和组装导弹的配置信息，那么新产出的火车可以提供运输和作战两种服务，同理一个容器可以运行php+nginx+mysql等不同的服务，一切来源于你的镜像。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，虽然容器内是虚拟环境，使用起来，就好像是在一个独立于宿主的系统下操作一样。\nDocker比传统虚拟机更快 Docker也是一种虚拟化技术。与传统虚拟机对比，虚拟机运行在虚拟硬件上，应用运行在虚拟机内核上。而 Docker daemon 是宿主机上的一个进程, 应用只是 Docker daemon 的一个子进程, 换句话说， 应用直接运行在宿主机内核上；虚拟机需要特殊硬件虚拟化技术支持，因而只能运行在物理机上。Docker 没有硬件虚拟化，因而可以运行在物理机、虚拟机，甚至 Docker 容器内(嵌套运行)；因为没有硬件虚拟化及多运行一个 Linux 内核的开销，应用运行在 Docker 上比虚拟机上更轻、更快。\n运行一个容器 了解相关概念之后开始练习使用。 1、首先在你的电脑上完成Docker的安装， 2、寻找自己想要使用的镜像文件 去Docker Hub（是一个集中存储镜像的服务，称为Docker Registry）上检索自己想要使用的服务，检索出的每条内容被称为一个仓库（Repository），每个仓库中有多个标签（tags，如php：5.5，其中php是仓库名，5.5是标签），一个标签对应一个镜像，拉取镜像到本地的命令是 ‘docker pull 镜像名:仓库名’， 如 docker pull php:5.5\n当标签是 latest 时，可省略： docker pull php 等同于 docker pull php:latest\n也可以通过命令行搜索，如搜索php相关镜像： docker search php\n请尝试下载一个nginx 镜像到本地，要指定标签。 3、查看本地镜像列表 docker images\n4、创建容器 docker run -d --name nginx-test -v /var/www:/var/www -p 8080:80 nginx\n-d,让容器在后台执行； –name，给容器分配名字 -v，挂载数据卷。容器像正常的Linux系统一样可以存储数据，但是当运行的容器出现故障不能正常启动时，我们就要通过同样的镜像运行一个新的容器实例，容器运行的服务是相同的，但是彼此隔离，不能共用数据，所以要通过数据卷的挂载实现数据的持久化。-v相当于把主机的/var/www目录同步到容器中的/var/www目录，如果容器不存在这个目录，则自动创建，挂载后两个文件夹实现了数据双向同步，每个容器的数据得以保存。新启用的nginx容器实例通过同样的挂载方式可以直接使用之前的数据。想要修改容器中nginx服务的配置，就要使用到数据卷，因为这是可变数据。数据卷是一个可供一个或多个容器使用的特殊目录，有如下特点，数据卷可以在容器之间共享和重用；对数据卷的修改会立马生效；对数据卷的更新，不会影响镜像；数据卷默认会一直存在，即使容器被删除 -p，端口映射，主机的8080端口映射到容器的80端口，此时访问主机8080会转到容器的80端口来获取数据 最后的nginx就是仓库名，会寻找nginx:latest的镜像启动，这里也可用本地镜像的id，镜像id通过 docker images 命令 可以得到\n容器的管理 容器启动之后，查看本地正在运行的容器 docker ps\n查看本地所有容器，包括运行中和暂停运行的 docker ps -a\n将暂停的容器启动 docker start 容器名称/容器id（容器id可用 docker ps 查看）\n暂停一个运行的容器 docker stop 容器名称/容器id\n删除一个容器,删除正在运行的容器要增加 -f 参数 docker rm 容器名称/容器id\n进入容器 进入容器的方式有多种，这里只介绍和推荐使用Docker自带的docker exec方式，Docker1.3增加新的exec命令行工具，进入container更加方便： docker exec -i -t 容器名称/id bash\nbash是容器系统的shell，如容器是centos系统，shell可以是bash、sh，进入容器后，尝试运行 ' ls / ' 命令\n结语 尝试运行一个容器实例，这会让你对Docker的有进一步理解。\n参考链接 http://jm.taobao.org/2016/05/12/introduction-to-docker/ https://yeasy.gitbooks.io/docker_practice/content/basic_concept/container.html\n","description":"","tags":["docker"],"title":"Docker初步学习-$k","uri":"/posts/docker%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0-k/"},{"categories":null,"content":"导语 下面内容将介绍如何把容器当作一个命令来使用以及搭建一套php+nginx的 web 服务，这里需要两个镜像，用两个镜像的主要目的是学习如何让 Docker 容器之间相互通信。阅读完下面的内容就可以搭建自己的 Docker 服务了。\n把 php 容器当作命令行使用 镜像下载： docker pull php:7.0-fpm-alpine php 这里的镜像是基于 alpine 系统的，因为基于alpine系统的镜像文件会比较小，下载速度更快。由于国内下载镜像文件较慢，推荐使用镜像加速器DaoCloud。 下载镜像是为了搭建一个 web 服务，如果只想简单的使用 php 命令行，怎么办？我们知道从镜像启动的容器中肯定是可以使用命令行，如果每次使用 php 命令行都进入容器，显得特别麻烦，其实 Docker 可以这样用： docker run -it --rm php:7.0-fpm-alpine php --version 命令比较长，给它设置个别名就好多了。下面介绍下相关参数： -i：以交互模式运行容器，通常与 -t 同时使用； -t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –rm：容器退出时自动删除，如果不加这个参数，当你执行完上面的命令，php容器会退出，变为一个暂停状态的容器，通过 docker ps -a 可以查询到； php –version：在容器名后面的字符会被当作容器的shell命令来处理； *注：关于参数 -i -t ，这里上面的命令可以不加，因为没有交互操作，在使用node容器的命令行时会有交互，需要加上，两个参数同时使用就好： docker run -i -t --rm node:alpine node\n想用容器同时执行多个命令，不能直接在后面加 \u0026\u0026，需要使用 sh -c 来实现，： docker run --rm php:7.0-fpm-alpine sh -c ' echo \"123\" \u0026\u0026 echo \"456\" ' \n启动php服务 执行命令：\ndocker run \\ -d \\ --name php \\ -v /root/docker/etc/php/php.ini:/usr/local/etc/php/conf.d/php.ini:ro \\ -v /root/docker/html:/var/www/html \\ php:7.0-fpm-alpine -d：后台运行容器，并且返回容器 ID； –name：给容器命名，容器名是唯一的，操作容器时可以使用名称代替容器 ID； :ro：表示挂载的文件或者文件夹为只读模式； 从命令可以知道容器是后台运行，名字是 php，它挂载了主机的一个文件 php.ini 和一个目录 /root/docker/html，并且 php.ini 是只读的，所以在容器内不可以对这个文件做修改。/usr/local/etc/php/conf.d 这个目录是容器中的 php 读取用户自定义配置文件的目录，正常情况下都可以在 Docker Hub 上有说明，如果没有可以自己运行 phpinfo(); 来查看。之前介绍过，只要挂载，那么本地主机目录就会和容器内的目录同步。需要修改容器的 php 配置时，只要在主机本地编辑保存这个 php.ini 文件，然后执行： docker restart php （php是容器名字）\nphp 容器和 nginx 容器通信 首先下载nginx镜像： docker pull nginx:stable-alpine 启动 nginx 服务：\ndocker run \\ -d \\ --link php \\ --name nginx \\ -v /root/docker/etc/nginx/conf.d/:/etc/nginx/conf.d/ \\ -v /root/docker/html:/var/www/html \\ -v /var/log/nginx:/var/log/nginx \\ -p 8088:80 \\ nginx:stable-alpine –link：确保 nginx 可以与 php 之间通信，在 nginx 容器中直接 ping php 是可以通的，实际上加上这个参数后，会在 nginx 容器增加 host 解析，如图：\n增加 nginx 虚拟主机配置，放到主机目录 /root/docker/etc/nginx/conf.d 下：\nserver { listen 80; root /var/www/html; # Add index.php to the list if you are using PHP index index.php index.html index.htm index.nginx-debian.html; location ~ \\.php$ { fastcgi_pass php:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log debug; } fastcgi_pass 后面使用的 php 就是 –link 参数增加的host解析，直接用别名代替ip地址，更加方便。然后重启 nginx 服务： docker restart nginx 在 主机本地的 /root/docker/html 目录新建 index.php： echo \"\u003c?php\\nphpinfo();\" | tee /root/docker/html/index.php 现在一个 web 服务搭建好了，如图：\n查看 nginx 日志 容器内 nginx 的日志会写入容器内的 /var/log/nginx 目录下，由于这个目录和主机的 /var/log/nginx 目录是同步的，所以，想看容器内 nginx 的日志，查看主机的文件 /var/log/nginx/access.log 就可以： tail -f /var/log/nginx/access.log\n结语 基本的启动配置服务的命令上面都有介绍，自己可以尝试给这个 web 服务增加个 mysql 存储功能。\n","description":"","tags":["docker","php"],"title":"Docker($k)搭建一套php开发环境","uri":"/posts/docker-k-%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97php%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"Chromeless 简介 Chrome 浏览器有一种模式叫做 Chrome Headless，在这种模式下，允许你正常运行 Chrome 浏览器，但是没有界面；想要调试这种模式下打开的网站，可以通过它提供的接口来实现，而 Chromeless 就是把这层接口做了封装，让你使用接口更方便。通过它，可以控制浏览器行为，如打开网站、点击按钮、填充表单、获取 DOM 元素…\n可以用来做什么 1 . 可以获取网页截图 2 . 根据页面 document 文档生成 PDF 文件 3 . 编写测试代码，自动化测试网页 4 . 基于真实的浏览器环境，可以编写爬虫程序\n安装 首先要安装支持 Chrome Headless 模式的浏览器。目前，Mac 上 Chrome 59 beta 版本与 Linux 上的 Chrome 57+ 已经开始支持 headless 特性。Windows 上 Chrome 暂时不支持，可以使用 Chrome Canary 60 进行开发。 下面是 Ubuntu17.10 的无界面浏览器启动命令示例：\ngoogle-chrome \\ --remote-debugging-port=9222 \\ --disable-gpu \\ --no-sandbox \\ --headless Chromeless 用 NodeJS 编写，要求 NodeJS 版本8.2+，安装： npm install chromeless\n如何用于网页测试 const { Chromeless } = require('chromeless') const { expect } = require('chai') async function run(){ const chromeless = new Chromeless() const firstPage= await chromeless .goto('http://www.w3school.com.cn') .wait('#navsecond') .evaluate(() =\u003e { // this will be executed in Chrome const links = [].map.call( document.querySelectorAll('#navsecond ul:nth-child(2) li'), a =\u003e (a.innerText.trim()) ) return links }) expect(firstPage).to.have.members([\"JS\",\"HTML5\",\"XHTML\",\"CSS\",\"CSS3\",\"TCP/IP\"]) await chromeless.end() } # 运行并捕捉错误 run().catch(console.error.bind(console)) 这里用到了 Chai 断言库，代码实现的功能是验证 W3school 网站首页，左侧第一个 ul 列表的内容是否包含以下内容： JS、HTML5、XHTML、CSS、CSS3、TCP/IP\"。 命令详解： goto：打开加载网站 http://www.w3school.com.cn； wait：等待指定的元素 #navsecond（这是 CSS selector） 渲染成功之后才往下执行； evaluate：会将里面的 JS 代码送到 浏览器中执行，并获取返回结果； 运行结果： 如何爬取 Google Search Result 下面代码实现的功能是使用 Google Search 搜索关键字，并返回结果的 Title 和链接地址。 查看执行结果\nconst { Chromeless } = require('chromeless'); async function run(){ const chromeless = new Chromeless() const firstPage= await chromeless .goto('https://www.google.com') .wait('input[name=\"q\"]') .type('云纵', 'input[name=\"q\"]') .press(13) // press enter .wait('#foot') let hasNextPage = true let page = 1 let result = null while (hasNextPage){ if(page===1){ result = await chromeless .evaluate(() =\u003e { // this will be executed in Chrome const links = [].map.call( document.querySelectorAll('.g h3 a'), a =\u003e ({title: a.innerText, href: a.href}) ) return links }) }else{ result = await chromeless .scrollTo(200,400) .scrollToElement('#foot td:nth-last-child(1)') .click('#foot td:nth-last-child(1)') .wait(2000) .wait('#foot') .evaluate(() =\u003e { // this will be executed in Chrome const links = [].map.call( document.querySelectorAll('.g h3 a'), a =\u003e ({title: a.innerText, href: a.href}) ) return links }) } console.log(result) hasNextPage = await chromeless.evaluate(() =\u003e { let nextPage = document.querySelector('#foot td:nth-last-child(1)').innerText //return (nextPage==='Next') return nextPage.length }) console.log(`第${page}页`) console.log(hasNextPage ? '存在下一页' : '不存在下一页') page++ } await chromeless.end() } run().catch(console.error.bind(console)) 命令解释： .type('云纵', 'input[name=\"q\"]')： 在 CSS 选择器 input[name=\"q\"] 选中的元素（实际上就是 Google Search 搜索框）内输入’云纵‘两个字； .press(13) ：按下键盘的 Enter 键，就是在搜索框输入文字后执行查询； .scrollTo(200,400) ：滚动到距离页面左侧200px，右侧400px的位置； .scrollToElement('#foot td:nth-last-child(1)')：滚动到 CSS 选择器 #foot td:nth-last-child(1) 选中元素（实际是 Google Search Result 的下一页链接），使元素可见； .click('#foot td:nth-last-child(1)')：点击元素； .wait(2000)：参数是数字时，表示等待时间，参数是 CSS 选择器时表示等待元素渲染完成；\nAsync 与 Await 开发时要注意这两个关键字 async 和 await，使用 Chromeless，会用到他们，这是 ES7 实现的异步方案，需要了解以下内容： 1 . function 前面的 async 标识符表示函数内有异步操作； 2 . await 强调后面的异步操作执行完成后才能继续； 3 . await 只能用在async标识的函数内； 4 . await 后写非异步操作也可以，会直接执行\n参考资料 1 . 体验异步的终极解决方案-ES7的Async/Await 2 . 初探 Headless Chrome\n","description":"","tags":["chromeless","headless"],"title":"Chromeless Demo","uri":"/posts/chromeless-demo/"},{"categories":null,"content":"Supervisor 介绍 Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器由于某种原因暂时 kill 掉你的应用，此时可以用 Supervisor 让你的应用自动重启，如果是多个应用被杀死，也省去了手动一个一个地敲命令重新启动。\n安装 目前 Supervisor 只能运行在 Unix-Like 的系统上，无法运行在 Windows 上。Supervisor 官方版目前只能运行在 Python 2.4 以上版本，但是还无法运行在 Python 3 上。执行下面代码前，需要安装 pip：\npip install supervisor  安装完成后，可以使用两个命令，分别是 supervisord 和 supervisorctl,如果你的系统里有两个版本的 Python，且默认的 python 命令版本是 Python 3,此时运行会出错，解决方式是修改两个命令使用的 Python 版本。使用 which 命令找到两个命令的文件地址，然后编辑文件并指定 Python 版本： 编辑配置文件 将下面内容保存到 /etc/supervisor/supervisord.conf:\n; 基础配置样例 [unix_http_server] file=/var/run/supervisor.sock ; (the path to the socket file) chmod=0700 ; sockef file mode (default 0700) [supervisord] logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log) pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid) childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP) ; the below section must remain in the config file for RPC ; (supervisorctl/web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket ; The [include] section can just contain the \"files\" setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. [include] files = /etc/supervisor/conf.d/*.conf ;加载其他配置文件 [inet_http_server] ; inet (TCP) server disabled by default port=*:9001 ; 通过网页可以控制子进程 ;username=user ; (default is no username (open server)) ;password=123 ; (default is no password (open server)) ; 进程的配置样例 ; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名，这里的进程名是 your_program_name [program:your_program_name] ;numprocs=1 ; 进程数量，默认为1 ;process_name=%(program_name)s ; 默认为 %(program_name)s，即 [program:x] 中的 x directory=/home/yiming ; 执行 command 之前，先切换到工作目录 command=python test.py autostart=true ;如果设置为true，当supervisord启动的时候，进程会自动重启。 user=yiming ; 使用 yiming 用户来启动该进程 autorestart=true ; 程序崩溃时自动重启，重启次数是有限制的，默认为3次 startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了 redirect_stderr=true ; 错误日志重定向到标准输出 loglevel=info 现在以守护进程的方式启动 test.py：\nsupervisord -c /etc/supervisor/supervisord.conf 此时命令 python test.ty 已经被执行，因为进程配置样例中有 autostart=true，所以 Supervisord 服务运行后启动进程 your_program_name ，并把 your_program_name 进程作为自己的子进程，所以当进程 your_program_name 挂掉后，Supervisord 会收到通知，然后可以再次将 your_program_name 作为子进程启动。\n模拟程序异常退出 如下图，名称为 echo 的进程被杀掉两次，之后都会被重新启动，右侧是 Supervisord 日志记录了 echo 进程状态的变化：\n使用 supervisorctl 管理进程  停止某一个进程，program_name 为 [program:x] 里的 x：  supervisorctl stop program_name  启动某个进程：  supervisorctl start program_name  重启某个进程：  supervisorctl restart program_name  停止全部进程，注：start、restart、stop 都不会载入最新的配置文件：  supervisorctl stop all  载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程：  supervisorctl reload  根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启：  supervisorctl update Web 管理 Supervisor 可以在界面上管理进程，Web Server 其实是通过 XML_RPC 来实现的，可以向Supervisor 请求数据，也可以控制 Supervisor 及子进程。配置在 [inet_http_server] 块里面：\n[inet_http_server] ; inet (TCP) server disabled by default port=*:9001 ; 通过网页可以控制子进程 ;username=user ; (default is no username (open server)) ;password=123 ; (default is no password (open server)) 配置参数介绍    参数 参数解释     command 启动程序使用的命令，可以是绝对路径或者相对路径   process_name 一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s   numprocs Supervisor启动这个程序的多个实例，如果numprocs\u003e1，则process_name的表达式必须包含%(process_num)s，默认是1   numprocs_start 一个int偏移值，当启动实例的时候用来计算numprocs的值   priority 权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999   autostart 如果设置为true，当supervisord启动的时候，进程会自动重启。   autorestart 值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。   startsecs 程序启动后等待多长时间后才认为程序启动成功   startretries supervisord尝试启动一个程序时尝试的次数。默认是3   exitcodes 一个预期的退出返回码，默认是0,2。   stopsignal 当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。   stopwaitsecs 在操作系统给supervisord发送SIGCHILD信号时等待的时间   stopasgroup 如果设置为true，则会使supervisor发送停止信号到整个进程组   killasgroup 如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。   user 如果supervisord以root运行，则会使用这个设置用户启动子程序   redirect_stderr 如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。   stdout_logfile 把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。   stdout_logfile_maxbytes 标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小   stdout_logfile_backups 标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份   stdout_capture_maxbytes 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB   stdout_events_enabled 如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发   stderr_logfile 把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true   stderr_logfile_maxbytes 错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小   stderr_logfile_backups 错误日志轮转备份的数量，默认是10，如果设置为0，则不备份   stderr_capture_maxbytes 当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB   stderr_events_enabled 如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发   environment 一个k/v对的list列表   directory supervisord在生成子进程的时候会切换到该目录   umask 设置进程的umask   serverurl 是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url    ","description":"","tags":["supervisor"],"title":"Supervisor 让崩溃的程序自动重启","uri":"/posts/supervisor-%E8%AE%A9%E5%B4%A9%E6%BA%83%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF/"}]
